# üîÅ Java 21 ‚Äî Streams and Functional Programming

Functional programming in Java has evolved from being ‚Äúsyntactic sugar‚Äù to a core paradigm that powers modern backend systems.  
The **Streams API** and **lambda expressions** enable concise, expressive, and parallelizable code ‚Äî all while maintaining type safety and immutability.

This chapter dives deep into **functional patterns**, **stream pipelines**, and **Java 21 enhancements** designed for experienced Java developers.

---

## üß≠ Table of Contents

1. [Functional Programming in Java](#1-functional-programming-in-java)
2. [Lambdas and Method References](#2-lambdas-and-method-references)
3. [Functional Interfaces and the `java.util.function` Package](#3-functional-interfaces-and-the-javautilfunction-package)
4. [Stream Basics ‚Äî What and Why](#4-stream-basics--what-and-why)
5. [Stream Creation](#5-stream-creation)
6. [Intermediate Operations (map, filter, flatMap)](#6-intermediate-operations-map-filter-flatmap)
7. [Terminal Operations (collect, reduce, forEach)](#7-terminal-operations-collect-reduce-foreach)
8. [Collectors and Grouping](#8-collectors-and-grouping)
9. [Parallel Streams and Performance](#9-parallel-streams-and-performance)
10. [Pattern Matching, Records, and Streams (Java 21)](#10-pattern-matching-records-and-streams-java-21)
11. [Streams with Virtual Threads (Java 21)](#11-streams-with-virtual-threads-java-21)
12. [Best Practices](#12-best-practices)
13. [Summary](#13-summary)

---

## 1Ô∏è‚É£ Functional Programming in Java

Functional programming (FP) emphasizes **immutable data**, **declarative transformations**, and **pure functions**.

Java introduced FP gradually:
- **Java 8** ‚Üí Lambdas, Streams, Optional  
- **Java 11‚Äì17** ‚Üí var, improved type inference  
- **Java 21** ‚Üí Pattern matching, records, virtual threads for FP pipelines  

Key advantages:
‚úÖ Concise code  
‚úÖ No shared mutable state  
‚úÖ Thread-safe, parallelizable design  

Example (imperative vs functional):

```java
// Imperative
List<String> names = new ArrayList<>();
for (String user : users)
    if (user.startsWith("A"))
        names.add(user.toUpperCase());

// Functional
List<String> names = users.stream()
    .filter(u -> u.startsWith("A"))
    .map(String::toUpperCase)
    .toList();
````

---

## 2Ô∏è‚É£ Lambdas and Method References

### üîπ Lambda Syntax

```java
(parameter) -> expression
```

Example:

```java
Runnable r = () -> System.out.println("Running...");
```

### üîπ Method References

Simplify calling existing methods:

```java
List<String> names = List.of("Nehru", "John", "Alice");
names.forEach(System.out::println);
```

### üîπ Four Common Forms:

| Type                              | Example                 |
| --------------------------------- | ----------------------- |
| Static method                     | `ClassName::methodName` |
| Instance method of object         | `instance::method`      |
| Instance method of arbitrary type | `String::toLowerCase`   |
| Constructor                       | `MyClass::new`          |

---

## 3Ô∏è‚É£ Functional Interfaces and the `java.util.function` Package

A **functional interface** has exactly one abstract method ‚Äî usable in lambdas.

### Common Functional Interfaces:

| Interface          | Method              | Example                                         |
| ------------------ | ------------------- | ----------------------------------------------- |
| `Predicate<T>`     | `boolean test(T t)` | `Predicate<String> isEmpty = s -> s.isEmpty();` |
| `Function<T,R>`    | `R apply(T t)`      | `Function<Integer,String> f = n -> "Num:" + n;` |
| `Consumer<T>`      | `void accept(T t)`  | `Consumer<String> c = System.out::println;`     |
| `Supplier<T>`      | `T get()`           | `Supplier<Double> rand = Math::random;`         |
| `UnaryOperator<T>` | `T apply(T t)`      | `UnaryOperator<Integer> square = n -> n * n;`   |

‚úÖ Use **composition**:

```java
Function<Integer, Integer> doubleIt = n -> n * 2;
Function<Integer, Integer> squareIt = n -> n * n;
Function<Integer, Integer> pipeline = doubleIt.andThen(squareIt);
System.out.println(pipeline.apply(3)); // (3*2)^2 = 36
```

---

## 4Ô∏è‚É£ Stream Basics ‚Äî What and Why

A **Stream** is a pipeline of operations on a data source.
It processes elements **lazily** and **immutably**.

Key features:

* Declarative processing
* Supports functional transformations
* Parallel execution support

> ‚öôÔ∏è Streams **do not store data** ‚Äî they operate on the source (collections, arrays, I/O, etc.)

---

## 5Ô∏è‚É£ Stream Creation

### üîπ From Collections

```java
Stream<String> stream = List.of("A", "B", "C").stream();
```

### üîπ From Arrays

```java
Stream<Integer> s = Arrays.stream(new Integer[]{1, 2, 3});
```

### üîπ Using Static Methods

```java
Stream<Double> randoms = Stream.generate(Math::random).limit(5);
Stream<Integer> numbers = Stream.iterate(1, n -> n + 1).limit(5);
```

### üîπ From Files

```java
try (Stream<String> lines = Files.lines(Path.of("data.txt"))) {
    lines.forEach(System.out::println);
}
```

---

## 6Ô∏è‚É£ Intermediate Operations (map, filter, flatMap)

| Operation    | Description               | Example                              |
| ------------ | ------------------------- | ------------------------------------ |
| `filter()`   | Select elements           | `.filter(n -> n > 10)`               |
| `map()`      | Transform elements        | `.map(String::toUpperCase)`          |
| `flatMap()`  | Flatten nested structures | `.flatMap(List::stream)`             |
| `distinct()` | Remove duplicates         | `.distinct()`                        |
| `sorted()`   | Sort elements             | `.sorted(Comparator.reverseOrder())` |
| `peek()`     | Debug or inspect          | `.peek(System.out::println)`         |

Example:

```java
List<String> names = employees.stream()
    .filter(e -> e.getSalary() > 50000)
    .map(Employee::getName)
    .sorted()
    .toList();
```

---

## 7Ô∏è‚É£ Terminal Operations (collect, reduce, forEach)

| Operation   | Description                         |
| ----------- | ----------------------------------- |
| `collect()` | Aggregate results into a collection |
| `reduce()`  | Combine into a single result        |
| `forEach()` | Consume the stream (void)           |

### Example: `collect()`

```java
List<String> highEarners = employees.stream()
    .filter(e -> e.getSalary() > 100000)
    .map(Employee::getName)
    .collect(Collectors.toList());
```

### Example: `reduce()`

```java
int total = Stream.of(10, 20, 30)
    .reduce(0, Integer::sum);
```

### Example: `forEach()`

```java
Stream.of("A", "B", "C").forEach(System.out::println);
```

---

## 8Ô∏è‚É£ Collectors and Grouping

```java
Map<String, List<Employee>> byDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment));

Map<String, Long> countByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.counting()));
```

### üîπ Joining

```java
String names = employees.stream()
    .map(Employee::getName)
    .collect(Collectors.joining(", "));
```

### üîπ Partitioning

```java
Map<Boolean, List<Employee>> partition = employees.stream()
    .collect(Collectors.partitioningBy(e -> e.getSalary() > 80000));
```

---

## 9Ô∏è‚É£ Parallel Streams and Performance

Parallel streams divide work across multiple threads.

```java
int total = numbers.parallelStream()
    .mapToInt(Integer::intValue)
    .sum();
```

‚úÖ Use when:

* Heavy CPU-bound computations
* Data source is large and thread-safe

‚ùå Avoid when:

* Stream involves I/O
* Small collections (overhead > benefit)

> üí° For fine-grained parallelism, combine **virtual threads (Java 21)** with stream processing.

---

## üîü Pattern Matching, Records, and Streams (Java 21)

Combine records and pattern matching for **type-safe, concise transformations**.

```java
sealed interface Payment permits CreditCard, UPI {}
record CreditCard(String id, double amount) implements Payment {}
record UPI(String upiId, double amount) implements Payment {}

List<Payment> payments = List.of(new CreditCard("123", 5000), new UPI("xyz@upi", 2000));

double total = payments.stream()
    .mapToDouble(p -> switch (p) {
        case CreditCard c -> c.amount();
        case UPI u -> u.amount();
    })
    .sum();
```

‚úÖ Clean, functional pattern matching
‚úÖ Eliminates `instanceof` checks
‚úÖ Perfect for event-driven and financial pipelines

---

## 11Ô∏è‚É£ Streams with Virtual Threads (Java 21)

Virtual threads (Project Loom) integrate naturally with functional patterns.

```java
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    List<Future<String>> results = Stream.of("Task1", "Task2", "Task3")
        .map(task -> executor.submit(() -> {
            Thread.sleep(1000);
            return task + " done by " + Thread.currentThread();
        }))
        .toList();

    results.forEach(r -> {
        try { System.out.println(r.get()); } catch (Exception e) { e.printStackTrace(); }
    });
}
```

‚úÖ 1000s of lightweight threads
‚úÖ Non-blocking stream pipelines
‚úÖ Ideal for **concurrent stream-based workflows**

---

## 12Ô∏è‚É£ Best Practices

‚úÖ Avoid modifying state inside streams
‚úÖ Prefer **method references** for clarity
‚úÖ Use `.parallel()` only for CPU-intensive workloads
‚úÖ Keep **pipelines pure and short**
‚úÖ Use `Collectors.toUnmodifiableList()` for immutability
‚úÖ Handle exceptions using wrappers like:

```java
Function<T, R> safe(Function<T, R> f) {
    return t -> {
        try { return f.apply(t); }
        catch (Exception e) { throw new RuntimeException(e); }
    };
}
```

‚úÖ Combine **Streams + Records + Sealed Types** for clean domain logic

---

## 13Ô∏è‚É£ Summary

In this chapter, you‚Äôve learned:

* How to build **functional pipelines** with Streams
* Use of **lambdas**, **collectors**, and **pattern matching**
* Integration of **virtual threads** for scalable concurrency
* Modern **record + sealed type** functional workflows

> üß≠ **Next Topic:** [13-concurrency-and-multithreading.md ‚Üí Advanced Concurrency in Java 21 (Virtual Threads, Executors, CompletableFuture)](./13-concurrency-and-multithreading.md)